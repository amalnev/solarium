# Solarium

Интерпретируемый язык программирования, нацеленный на автоматизацию рутинных задач сетевого администрирования. Также может применяться для организации автоматизированного тестирования веб-приложений и приложений с консольным интерфейсом.

### Область применения
Основная область применения данного языка - автоматизация задач сетевого администриования на больших сетях, построенных на оборудовании разных вендоров. Работа администратора таких сетей зачастую связана с рутинными операциями, которые нужно выполнить на большом количестве разных устройств, предоставляющих разные интерфейсы управления - консоли с разными языками конфигурирования, веб-интерфейсы, отличающиеся от устройства к устройству и от одной версии прошивки к другой и т.д. "Большие" корпоративные сетевые решения от ведущих вендоров, применяющиеся крупными операторами связи, как правило предоставляют унифицированные средства управления, но существует и сегмент операторов последних миль и сетей уровня доступа, применяющих более простые решения, не снабженные подобными мощными средствами управления "из коробки". Такие сети могут представлять собой набор из разнообразных элементов, относящихся как к "операторскому", так и к более низким классам надежности, произведенных различными вендорами и т.д., при этом сохраняется необходимость соблюдать некоторую степень единообразия в их конфигурации, применяющихся версиях прошивок, наименовании устройств и сервисов. Все это приводит к тому, что рано или поздно перед администратором такой сети ставятся задачи наподобие "поменять SNMP community на всех сетевых устройствах" или "определить все устройства определенного типа с определенной версией прошивки для последующего обновления". Solarium позволяет автоматизировать выполнение подобных задач. Solarium - это средство автоматизации пользовательских интерфейсов, выполненное в виде языка программирования. На этом языке можно писать скрипты, манипулирующие непосредственно интерфейсами сетевых устройств так, как это делал бы сетевой администратор "руками". С точки зрения устройства нет разницы, кто с ним взаимодействует - живой человек или Solarium-робот, поэтому никакой дополнительной поддержки со стороны управляемых устройств не требуется.

### Примеры
Перед тем как перейти к формальному описанию языка и его возможностей, приведем несколько быстрых и простых примеров Solarium-скриптов.

1. #### Определить устройства, отвечающие на пинг
    ```javascript 1.8
    for(ipAddress: ipRange("192.168.1.0/24")){
       if(ipAddress.isReachable())
           println(ipAddress);
    }
    ```
    Как видно из этого примера, язык обладает C-образным синтаксисом, поддерживает такие примитивы как переменные, функции и управляющие конструкции, например циклы "for" и ветвления. В данном конкретном случае встроенная функция ```ipRange()``` разворачивает стандартную нотацию IPv4-подсети в массив отдельных адресов, принадлежащих к этой подсети. Далее цикл ```for``` пробегает по всем элементам данного массива и с помощью встроенной функции ```isReachable()``` проверяет доступность соответствующего адреса с помощью ICMP echo, более известного как ping. В случае, если выражение ```ipAddress.isReachable()``` оценивается как ```true``` (то есть адрес пингуется), то данный адрес будет напечатан в консоль, из которой скрипт был запущен.

2. #### Опросить устройства по SNMP
    ```javascript 1.8
   for(ipAddress: ipRange("10.123.22-23.0-255")){
       if(ipAddress.isReachable()){
           hostname = getOID("1.3.6.1.2.1.1.5.0", ipAddress, "public", "1");
           if(hostname != null){
               println(ipAddress + " -> " + hostname);
           }
       }
   }
    ```
    Данный скрипт проверяет все IP-адреса из заданного диапазона и для тех адресов, которые оказываются доступны по пингу, пытается получить значение SNMP-объекта "1.3.6.1.2.1.1.5.0" (т.е. сетевое имя устройства) по протоколу SNMP 1-й версии, используя community "public". Это делается с помощью встроенной функции ```getOID()```, результат ее работы сохраняется в переменную ```hostname```. В случае, если вызов функции завершился успешно, в консоль выводится IP-адрес успешно опрошенного устройства и его сетевое имя.
    
3. #### Зайти на устройство и выполнить консольные команды
    Довольно часто встречающаяся в реальной работе задача - обновить конфигурацию на нескольких однотипных устройствах. Вот как это можно сделать с помощью Solarium:
    ```javascript 1.8
    hosts = ["192.168.1.1", "192.168.2.14", "10.10.1.34"];
    commandPrompt = "[>|\\]]";
    commands = ["system-view", 
                "snmp-agent community read cipher community123",
                "q",
                "save",
                "y"];
 
    for(host: hosts){
       sshConnection = host.ssh("admin", "admin");
       if(sshConnection != null){
           console = sshConnection.getConsole();
           console.expect(commandPrompt);
           for(command: commands){
               console.writeLine(command);
               console.expect(commandPrompt);
           }
           
           console.close();
           sshConnection.close();        
       }
    }
    ``` 
    Этот скрипт посещает все хосты из заданного списка, пытается соединиться с каждым по SSH, и в случае, если соединение удалось установить, выполняет серию команд. В данном случае мы поменяли SNMP community на 3-х устройствах под управлением ОС Huawei VRP и сохранили конфигурацию.
    
4. #### Зайти на устройство через веб-интерфейс
    ```javascript 1.8
    browser = firefox();
    if(browser.openPage("http://192.168.1.1")){
       browser.findElementById("username").sendKeys("admin");
       browser.findElementById("password").sendKeys("admin");
       browser.click(browser.findElementById("loginButton"));
    
       sleep(3000);
       println(browser.getPageTile());
    }
    browser.closeBrowser();
    ```
    Этот скрипт демонстрирует автоматизацию веб-интерфейсов. Запускается браузер FireFox и в нем открывается веб-интерфейс устройства с IP-адресом 192.168.1.1. Если HTML-страница открылась, то на ней ищутся текстовые поля для ввода имени пользователя и пароля, в них вводятся соответствующие данные. Далее скрипт нажимает на HTML-кнопку входа в устройство и ждет 3 секунды, позволяя браузеру подгрузить следующую страницу, после чего в консоль печатается заголовок этой страницы. После этого окно браузера закрывается.
    
### Ограничения
Формально Solarium является языком программирования общего назначения и теоретически его можно использовать для построения систем любой сложности. Но изначально он планировался как язык для написания коротких и "конкретных" скриптов, автоматизирующих простые повторяющиеся действия. В нем отсутствуют средства абстракции, нет сильной типизации, нет средств, позволяющих структурировать большие объемы кода. Это именно средство для автоматизации повседневной рутины сетевого администратора, выполненное в виде языка программирования для того, чтобы макисмально гибко адаптироваться под решение широкого круга задач. Solarium не является средством для написания больших и сложных программных систем, его ниша - это своего рода VBA для сетевого администратора.

### Запуск скриптов на Solarium.
Solarium является интерпретируемым языком, исходный код которого не преобразуется в тот или иной бинарный формат для последующего выполнения, а непосредственно читается и выполняется программой-интерпретатором. Для того, чтобы запустить скрипт на языке Solarium, необходимо сохранить его в текстовый файл в кодировке UTF-8. После этого нужно запустить интерпретатор и указать ему путь к файлу, содержащему скрипт:
```bash
java -jar solarium.jar /path/to/script.txt
```
Интерпретатор Solarium - это консольное приложение, написанное на Java и содержащееся вместе со всеми своими зависимостями в едином архиве solarium.jar. Для его запуска требуется JRE 1.8 или выше.

### Переменные.
Solarium является языком со слабой типизацией. Формальное объявление (declaration) переменных не требуется. Переменная автоматически определяется (definition) в момент ее первого использования. Переменные могут содержать скалярное значение или являться массивами. В обоих случаях переменная может содержать дополнительные именованные поля по примеру ООП-объектов. Значение каждого такого поля также может являться скаляром или массивом и содержать дополнительные именовааные поля. Следующий пример демонстрирует особенности работы с переменными в Solarium:
```javascript 1.8
/*Определяем переменные и присваиваем им начальные значения*/
a = 10;
b = "Some string";

/*b теперь становится массивом, строковое значение "Some string"
* забывается.*/
b = b.append(10);
b = b.append(20);

/*Напечатается: [10, 20]*/
println(b);

/*Добавляем в переменную a несколько полей. Теперь а является 
* аналогом объекта в ООП-языках. */
a.stringField = "Some string";
a.integerField = 100;

/*При этом скалярное значение 10, хранившееся в переменной a 
не забывается, следующий вызов напечатает: 10*/
println(a);

/*Помимо строковых и целочисленных литералов поддерживается также
* специальное значение null*/
c = null;
```
В версии языка 0.0.1 все переменные находятся на стеке и передаются только по значению. Используя термины C++ можно сказать, что здесь нет разделения на r-value и l-value, все является l-value.

### Операторы.
Поддерживаются стандартные арифметические операторы +,-,/,*,<,>,<=,>=,%. В текущей экспериментальной версии языка реализована только целочисленная арифметика. Таким образом:
```javascript 1.8
a = 25;

/*Напчатается: 2*/
println(a / 10);
```

Оператор "+" может применяться к строкам и означает конкатенацию:
```javascript 1.8
a = "Some ";
b = "string";

/*Напечатается: 'Some string'*/
print(a + b);
```

Поддерживаются логические операторы == (равно), != (не равно), !(отрицание), && (логическое И), || (логическое ИЛИ):
```javascript 1.8
/*Напечатает: true*/
println(!(10 != 11) || (10 == 10));
```

Поддерживаются стандартные правила ассоциативности операторов и скобки:
```javascript 1.8
/*Напечатается: 22*/
println(5 + 2*10 - 6/2);

a = true; b = false; c = true;

/*Напечатается: true*/
println(a || c && a || b);
```

### Строки и регулярные выражения
В предыдущем параграфе была рассмотрена конкатенация строк. Также при написании строковых литералов можно использовать escape sequences для добавления в строку специальных символов:
```javascript 1.8
a = "abc\ndef\tghi\"jkl\"";

/*Напечатает: 
* abc
* def   ghi"jkl"
* */
println(a);
```
Библиотека языка содержит некоторые функции, облегчающие работу со строками. Например, можно проверить содержит ли строка заданную подстроку:
```javascript 1.8
a = "abcd";

/*Напечатает: true*/
println(a.contains("bc"));
```
Можно проверить, является ли заданная подстрока префиксом некоторой строки:
```javascript 1.8
a = "abcd";

/*Напечатает: true*/
println(a.contains("ab"));
```
Конвертирование символы в заглавные:
```javascript 1.8
a = "abcd";

/*Напечатает: ABCD*/
println(a.toUpperCase());
```
Проверка, удовлетворяет ли некоторая строка заданному регулярному выпражению:
```javascript 1.8
a = "abcd";

/*Напечатает: true*/
println(a.matches("[a-z]+"));
```
Наконец, приведем пример парсинга текста с помощью регулярного выражения. Функция grep() возвращает массив, в котором каждый элемент соответствует одному найденному совпадению в исходном тексте. При этом каждый элемент возвращаемого массива в свою очередь является массивом, состоящим из строк, соответствующих подгруппам регулярного выражения - 0-й элемент дает всю найденную строку, 1-й и далее - дают подстроки, соответсвующие подгруппам, если таковые присутствовали в регулярном выражении. Например:
```javascript 1.8
text = "abcd 11-45 fdgr 2-00";
pattern = "([0-9]+)-([0-9]+)";
for(match: pattern.grep(text)) {
    for(submatch: match){
        println(submatch);
    }
}

/*Будет напечатано:
  11-45 (первое совпадение целиком)
  11 (первая подгруппа в первом совпадении)
  45 (вторая подгруппа в первом совпадении)
  2-00 (второе совпадение целиком)
  2 (первая подгруппа во втором совпадении)
  00 (вторая подгруппа во втором совпадении)
 */
``` 
### Управляющие конструкции
Язык поддерживает полный набор управляющих конструкций. Ветвления:
```javascript 1.8
if(expression_returning_boolean) {
    //...
}
else if(expression_returning_boolean) {
    //...
}
else {
    //...
}
```
Циклы for со счетчиком:
```javascript 1.8
for(i = 0; i < 10; i = i + 1) {
    /*К сожалению, в экспериментальной версии нет поддержки операторов ++ и --.*/
}
```
Циклы for по массиву элементов:
```javascript 1.8
arr = [10, 20, 30];
for(element: arr) {
    println(element);
}

/*Напечатает:
 10
 20
 30
*/
```
Циклы do-while:
```javascript 1.8
do {
    /*Infinite loop*/
} while(true);
```
Циклы while:
```javascript 1.8
while (true) {
    /*Infinite loop*/
} 
```
Внутри циклов можно использовать операторы break и continue:
```javascript 1.8
arr = [10, 20, 30, 40, 50, 60];
for(element: arr) {
    if(element < 30) continue;
    if(element > 40) break;
    println(element);
}

/*Напечатает:
 30
 40
*/
```

### Функции
Язык позволяет выделять часть кода в функцию и вызывать ее из другой функции:
```javascript 1.8
function f(a){
    return a + 10;
}

/*Напечатается: 20*/
println(f(10));
```
В приведенном выше примере строка кода ```println(f());``` не содержится внутри какой-либо функции. Интерпретатор начнет выполнение данного скрипта именно с первой строки, не находящейся внутри функции. Увидев, что для выполнения этой строки нужно вызвать функцию f(), интерпретатор найдет ее определение и вызовет с заданными праметрами. Парасетры передаются в функцию всегда по значению:
```javascript 1.8
function f(a, b) {
    a = a + 10;
    b = b + 20;
}

x = 10; y = 20;
f(x, y);

/*Напечатается: 10*/
println(x);

/*Напечатается: 20*/
println(y);
```
При вызове функции интепретатор завершает выполнение ее кода достигнув последней инструкции в теле функции или встретив оператор return. Кроме того, оператор return - единственный способ вернуть из функции какое-либо значение. Если функция в явном виде не возвращает никакого значения, то по умолчанию считается, что она вернула null:
```javascript 1.8
function f(){
    //do something
    return;
}

/*Напечатает true*/
println(f() == null);
```
Язык подерживает специальный ООП-образный синтаксис для вызова функций - "через точку":
```javascript 1.8
function plus(x, y) {
    return x + y;
}

a = 10; b = 20;

/*Напечатает: 30*/
println(a.plus(b));

/*Напечатает: 30*/
print(plus(a,b));

```
То есть для функции ```f(x, y)``` вызов ```x.f(y)``` эквивалентен вызову ```f(x, y)```.

### Исходные файлы и препроцессор
Как уже говорилось выше, для запуска скрипта на языке Solarium, его необходимо сохранить в текстовый файл в кодировке UTF-8 и передать на выполнение интерпретатору. Интерпретатор открывает переданный ему файл, и начинает выполнять построчно, начиная с первой строки кода, не содержащейся в той или иной функции. Код, содержащийся в функциях, выполняется при вызове этих функций. Но еще до того, как интерпретатор получит доступ к исходному коду, он обрабатывается перепроцессором. Задача перпроцессора заключается в подготовке исходного кода к интерпретации, при этом автор скрипта может влиять на этот процесс при помощи директив препроцессора, по аналогии с языками С/С++. В экспериментальной версии Solarium поддерживается только одна препроцессорная директива - #include. Она позволяет разбить большой скрипт на несколько исходных файлов, а перед интерпретацией объединить их. Например, на диске есть директория scripts, содержащая скрипты main.txt и functions.txt, а также вложенная директория library, содержащая скрипт library.txt:
 ```bash
$ ls -lRa
.:
total 12
drwxr-xr-x 3 amalnev amalnev 4096 Nov 19 14:45 .
drwxr-xr-x 3 amalnev amalnev 4096 Nov 19 14:45 ..
-rw-r--r-- 1 amalnev amalnev    0 Nov 19 14:45 functions.txt
drwxr-xr-x 2 amalnev amalnev 4096 Nov 19 14:45 library
-rw-r--r-- 1 amalnev amalnev    0 Nov 19 14:45 main.txt

./library:
total 8
drwxr-xr-x 2 amalnev amalnev 4096 Nov 19 14:45 .
drwxr-xr-x 3 amalnev amalnev 4096 Nov 19 14:45 ..
-rw-r--r-- 1 amalnev amalnev    0 Nov 19 14:45 library.txt
```

Предположим, что скрипт library.txt содержит некоторые "библиотечные" функции:
```javascript 1.8
/*Содержимое library.txt*/
function sum (a, b) {
    return a + b;
}

function div (a, b) {
    return a / b;
}
```

Скрипт functions.txt использует "библиотечные" функции:
```javascript 1.8
/*Содержимое functions.txt*/

#include("library/library.txt");

function avg(arr) {
    arrayTotal = 0;
    for(element: arr) {
        arrayTotal = arrayTotal.sum(element);
    }
    
    return arrayTotal.div(arr.size());
}
```

Скрипт main.txt - это точка входа, с которой интерпретатор будет начинать работу, когда мы запустим его при помощи команды ```java -jar solarium.jar main.txt```:
```javascript 1.8
#include("functions.txt");

a = [10, 20, 30];

/*Напечатает: 20*/
println(a.avg());
```

Что происходит в приведенном выше примере? Препроцессор читает исходный код, начиная с файла main.txt, поскольку именно его мы указали как точку входа при запуске Solarium-а. Увидев директиву ```#include("functions.txt");``` препроцессор открывает указанный файл, рекурсивно обрабатывает его и результат подставляет вместо текста директивы #include. Таким образом, интерпретатору на выполнение попадет исходный код, "сшитый" из содержимого нескольких файлов. Необходимо заметить, что пути к файлам в директиве #include всегда интерпретируются относительно той директории, в которой находится файл, содержащий данную директиву. 

### Библиотека функций и пример использования Solarium при решении реальной производственной задачи.
В этом разделе предлагается рассмотреть пример "боевого применения" Solarium и заодно совершить небольшой обзор библиотеки встроенных функций, которые как раз и позволяют использовать язык для решения задач сетевого администрирования. Встроенные функции - это функции, являющиеся частью самого языка, они реализованы не на Solarium, а могут лишь вызываться из Solarium-скриптов. 

#### Постановка задачи.
Итак, рассмотрим пример из реальной практики. Имеется провайдерская сеть уровня доступа, состоящая из большого количества разных активных сетевых устройств - L2 и L3 коммутаторов, радиомостов, базовых станций и абонентских терминалов WiMax, демаркационных устройств, CPE роутеров и т.д. Все эти устройства управляются по IP и сети управления терминируются на корневых маршрутизаторах провайдера. Управление устройствами осуществляется либо с помощью консолей, доступных по протоколам telnet или ssh, либо с помощью веб-интерфейсов. 

В связи с миграцией корпоративных систем мониторинга на новое ПО, вышестоящее техническое подразделение компании выпускает новые требования по конфигурации сетевых устройств. Теперь все устройства должны отправлять свои логи на общий syslog-сервер и уведомлять об авариях посредством SNMP-трапов.

Общее количество устройств, конфигурацию которых нужно привести в соответствие новым требованиям, составляет несколько тысяч штук, что практически исключает возможность работы вручную. Вместо этого мы разработаем процедуры миграции с разбивкой по типу устройств и их производителю, запишем эти процедуры в виде Solarium-скриптов, а затем централизованно применим на сети. И первым шагом здесь будет проведение фактической инвентаризации - составление списка доступных сетевых устройств, определение их типа, производителя и модели. Решение именно этой предварительной задачи мы и рассмотрим.

#### Технический подход к решению
Поскольку подсети, из которых выделяются IP-адреса управления устройств, нам известны, мы можем поступить следующим образом - просканировать подсети управления при помощи ICMP эхо-запросов, составить список ответивших на эхо IP-адресов, а также проверить ARP-таблицы на корневых маршрутизаторах. Это позволит выяснить MAC-адреса устройств, что в дальнейшем поможет при их идентификации. Дополнительно опросив доступные устройства по SNMP мы сможем идентифицировать их производителя, модель и сетевое имя. Если устройство не отвечает ни на одно из известных SNMP community, то мы можем использовать его MAC, для того чтобы по крайней мере определить производителя. Результат сканирования мы сформируем в виде CSV-таблицы, пригодной для импорта в MS Excel. Эта таблица будет содержать следующие поля: IP-адрес устройства, доступность по ICMP, доступность по SNMP, SNMP community, сетевое имя устройства, производитель, модель.

#### Решение
Далее приводится исходный код скрипта на Solarium, являющегося решением поставленной задачи, с подробными комментариями.
```javascript 1.8

/*Данная вспомогательная функция опрашивает заданное устройство по SNMP в соответствии 
* со списком community. Возвращается первое community из списка, на которое будет получен
* ответ. Если устройство не ответит ни на одно community из списка, то функция вернет null*/
function snmpCommunity(ipAddress, knownCommunities) {
    for(community: knownCommunities) {
        
        /*Встроенная функция getOID() производит фактический опрос оборудования
        * "1.3.6.1.2.1.1.2.0" - это OID sysObjectID, присутствующий на любых устройствах 
        * 4-й параметр ("1") - это версия протокола */
        if(getOID("1.3.6.1.2.1.1.2.0", ipAddress, community, 1) != null) 
            return community;
    }
    return null;
}

/*Данная вспомогательная функция определяет производителя устройства по значению
* SNMP-объекта sysObjectID. Реализация функции здесь не приводится из соображений
* компактности, но в сущности она заключается в поиске элемента в массиве элементов,
* который получается в результате парсинга большого текстового файла данных, который 
* можно скачать по данному адресу:
* https://github.com/fusioninventory/sysobject.ids*/
function lookupVendor(sysObjectID) {
    /*...*/
}

/*Данная вспомогательная функция определяет модель устройства по значению
* SNMP-объекта sysObjectID.*/ 
function lookupModel(sysObjectID) {
    /*...*/
}

/*Данная вспомогательная функция определяет производителя устройства по MAC-адресу.
* Для этого воспользуемся услугами сайта macvendors.com*/
function lookupVendorByMac(macAddress) {
    
    /*Запускаем браузер*/
    browser = firefox();
    
    /*Открываем сайт macvendors.com*/
    browser.openPage("https://macvendors.com");
    
    /*Пишем интересующий нас MAC в поле для ввода MAC-адреса*/
    browser.findElementById("macaddress").sendKeys(macAddress);
    
    /*Ждем некоторое время, чтобы сайт успел отработать запрос 
    (он это делает асинхронно через JS, а не перезагружает страницу)*/
    sleep(3000);
    
    /*Находим на странице результат*/
    result = browser.findElementById("vendor").getAttribute("innerHTML");
    
    /*Закрываем браузер и возвращаем результат*/
    browser.closeBrowser();
    return result;
}

/*Эта функция соединяется с корневым маршрутизатором и выгружает с него таблицу
* ARP-записей. Данная конкретная реализация написана для маршрутизатора
* Huawei, но принцип тот же для любого оборудования:
* 1) Соединяемся по SSH или TELNET
* 2) Послыаем в консоль команду, печатающую ARP-таблицу, получаем результат
* 3) Закрываем соединение и парсим результат
* */
function loadArpTable(router, username, password) {
    /*Открываем соединение по SSH*/
    sshConnection = ssh(router, username, password);
    
    /*Получаем консольный интерфейс*/
    sshConsole = sshConnection.getConsole();
    
    /*Ждем, пока в консоли появится приглашение на ввод команд (command prompt)*/
    sshConsole.expect(">");
    
    /*Пишем в консоль команду на отображение ARP-таблицы*/
    sshConsole.writeLine("dis arp vpn-instance OAM all");
    
    /*Ждем, пока в консоли появится приглашение на ввод команд (command prompt)
    * Все, что было напечатано в консоль устройством, запоминаем для 
    * последующей обработки. */
    output = sshConsole.expect(">");
    
    /*Послыаем в консоль команду на выход*/
    sshConsole.writeLine("quit");
    
    /*Закрываем консоль и SSH-соединение*/
    sshConsole.close();
    sshConnection.close();
    
    /*Парсим содержимое консоли. Находим в нем с помощью регулярного выражения
    * ARP-записи и формируем результат в виде массива элементов, каждый из 
    * которых в свою очередь представляет собой массив из двух элементов - 
    * IP-адреса и соответствующего ему MAC-адреса*/
    arpRecords = [];
    arpRecordMatches = grep("([0-9\.]+)\s+([0-9a-fA-F\-]{14})", output);
    for(arpRecordMatch: arpRecordMatches) {
        arpRecord = [arpRecordMatch[1], arpRecordMatch[2]];
        arpRecords = arpRecords.append(arpRecord);
    }
    
    return arpRecords;
}

/*Данная функция ищет заданный IP-адрес в ARP-таблице, выгруженной предыдущей
* функцией с корневого маршрутизатора.*/
function getMacAddress(arpRecords, ipAddress) {
    for(arpRecord: arpRecords) {
        if(arpRecord[0] == ipAddress) {
            return arpRecord[1];
        }
    }
    
    return null;
}

/*Эта переменная хранит информацию об IP-адресации наших сетей управления.
* Каждый элемент массива содержит информацию о диапазоне IP-адресов, который необходимо
* просканировать и об адресе корневого маршрутизатора, на котором терминируется 
* соответствующая подсеть*/
ipPlan = [
    ["192.168.1-2.0-255", "192.168.1.1"],
    ["192.168.10.0-255", "192.168.10.1"]
];

/*Эта переменная содержит список SNMP community, которые могут существовать
* на нашей сети*/
knownCommunities = ["public", "private", "some_community"];

/*В этот массив мы будем записывать результаты сканирования. Каждый элемент массива 
* будет содержать данные по одному найденному сетевому устройству*/
scanResult = [];

/*Обрабатываем наш IP-план*/
for(ipPlanElement: ipPlan) {
    ipAddressRange = ipPlanElement[0];
    coreRouter = ipPlanElement[1];
    
    /*Выгружаем ARP-таблицу с корневого роутера*/
    arpTable = loadArpTable(coreRouter, "admin", "admin");
    
    /*Функция ipRange "разворачивает" строковое представление диапазона 
    * IP-адресов в массив, состоящий из отлельных адресов, принадлежащих 
    * к этому диапазону*/
    for(ipAddress: ipRange(ipAddressRange)) {
        
        /*В эту переменную будем складывать результаты сканирования 
        * текущего IP-адреса*/
        deviceResult = null;
        deviceResult.ipAddress = ipAddress;
        
        /*Функция isReachable() проверяет доступность устройства по протоколу
        * ICMP. true возвращается, если устройство отвечает на эхо-запросы*/        
        if(ipAddress.isReachable()) {
            
            /*Устройство доступно.*/
            deviceResult.icmp = true;
            
            /*Теперь попробуем опросить его по SNMP*/
            deviceResult.community = snmpCommunity(ipAddress, knownCommunities);
            if(deviceResult.community == null) {
                /*Устройство не ответило по SNMP, определим его производителя по MAC*/
                macAddress = getMacAddress(arpTable, ipAddress);
                deviceResult.vendor = lookupVendorByMac(macAddress);
            }
            else {
                /*Устройство ответило по SNMP, определяем его sysObjectID*/
                sysObjectID = getOID("1.3.6.1.2.1.1.2.0", ipAddress, deviceResult.community, 1);
                
                /*Определяем модель и производителя*/
                deviceResult.vendor = lookupVendor(sysObjectID);
                deviceResult.model = lookupModel(sysObjectID);
                
                /*Определяем сетевое имя*/
                deviceresult.sysname = getOID("1.3.6.1.2.1.1.5.0", ipAddress, deviceResult.community, 1);
            }
        }
        
        scanResult = scanResult.append(deviceResult);
    }
}

/*В данный момент массив scanResult содержит результаты сканирования по всем устройствам.
* Сформируем CSV-таблицу, пригодную для импорта в MS EXcel*/
csvResult = "IP, ICMP, COMMUNITY, SYSNAME, VENDOR, MODEL\n";
for(deviceResult: scanResult) {
    csvResult = csvResult + deviceResult.ipAddress + ", " + 
        deviceResult.icmp + ", " + 
        deviceResult.community + ", " + 
        deviceResult.sysname + ", " + 
        deviceResult.vendor + ", " + 
        deviceResult.model + "\n";
}

/*Записываем результат в файл*/
writeFile("output.txt", csvResult);
```