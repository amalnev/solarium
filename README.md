# Solarium

Интерпретируемый язык программирования, нацеленный на автоматизацию рутинных задач сетевого администрирования. Также может применяться для организации автоматизированного тестирования веб-приложений и приложений с консольным интерфейсом.

### Область применения
Основная область применения данного языка - автоматизация задач сетевого администриования на больших сетях, построенных на оборудовании разных вендоров. Работа администратора таких сетей зачастую связана с рутинными операциями, которые нужно выполнить на большом количестве разных устройств, предоставляющих разные интерфейсы управления - консоли с разными языками конфигурирования, веб-интерфейсы, отличающиеся от устройства к устройству и от одной версии прошивки к другой и т.д. "Большие" корпоративные сетевые решения от ведущих вендоров, применяющиеся крупными операторами связи, как правило предоставляют унифицированные средства управления, но существует и сегмент операторов последних миль и сетей уровня доступа, применяющих более простые решения, не снабженные подобными мощными средствами управления "из коробки". Такие сети могут представлять собой набор из разнообразных элементов, относящихся как к "операторскому", так и к более низким классам надежности, произведенных различными вендорами и т.д., при этом сохраняется необходимость соблюдать некоторую степень единообразия в их конфигурации, применяющихся версиях прошивок, наименовании устройств и сервисов. Все это приводит к тому, что рано или поздно перед администратором такой сети ставятся задачи наподобие "поменять SNMP community на всех сетевых устройствах" или "определить все устройства определенного типа с определенной версией прошивки для последующего обновления". Solarium позволяет автоматизировать выполнение подобных задач. Solarium - это средство автоматизации пользовательских интерфейсов, выполненное в виде языка программирования. На этом языке можно писать скрипты, манипулирующие непосредственно интерфейсами сетевых устройств так, как это делал бы сетевой администратор "руками". С точки зрения устройства нет разницы, кто с ним взаимодействует - живой человек или Solarium-робот, поэтому никакой дополнительной поддержки со стороны управляемых устройств не требуется.

### Примеры
Перед тем как перейти к формальному описанию языка и его возможностей, приведем несколько быстрых и простых примеров Solarium-скриптов.

1. #### Определить устройства, отвечающие на пинг
    ```javascript 1.8
    for(ipAddress: ipRange("192.168.1.0/24")){
       if(ipAddress.isReachable())
           println(ipAddress);
    }
    ```
    Как видно из этого примера, язык обладает C-образным синтаксисом, поддерживает такие примитивы как переменные, функции и управляющие конструкции, например циклы "for" и ветвления. В данном конкретном случае встроенная функция ```ipRange()``` разворачивает стандартную нотацию IPv4-подсети в массив отдельных адресов, принадлежащих к этой подсети. Далее цикл ```for``` пробегает по всем элементам данного массива и с помощью встроенной функции ```isReachable()``` проверяет доступность соответствующего адреса с помощью ICMP echo, более известного как ping. В случае, если выражение ```ipAddress.isReachable()``` оценивается как ```true``` (то есть адрес пингуется), то данный адрес будет напечатан в консоль, из которой скрипт был запущен.

2. #### Опросить устройства по SNMP
    ```javascript 1.8
   for(ipAddress: ipRange("10.123.22-23.0-255")){
       if(ipAddress.isReachable()){
           hostname = getOID("1.3.6.1.2.1.1.5.0", ipAddress, "public", "1");
           if(hostname != null){
               println(ipAddress + " -> " + hostname);
           }
       }
   }
    ```
    Данный скрипт проверяет все IP-адреса из заданного диапазона и для тех адресов, которые оказываются доступны по пингу, пытается получить значение SNMP-объекта "1.3.6.1.2.1.1.5.0" (т.е. сетевое имя устройства) по протоколу SNMP 1-й версии, используя community "public". Это делается с помощью встроенной функции ```getOID()```, результат ее работы сохраняется в переменную ```hostname```. В случае, если вызов функции завершился успешно, в консоль выводится IP-адрес успешно опрошенного устройства и его сетевое имя.
    
3. #### Зайти на устройство и выполнить консольные команды
    Довольно часто встречающаяся в реальной работе задача - обновить конфигурацию на нескольких однотипных устройствах. Вот как это можно сделать с помощью Solarium:
    ```javascript 1.8
    hosts = ["192.168.1.1", "192.168.2.14", "10.10.1.34"];
    commandPrompt = "[>|\\]]";
    commands = ["system-view", 
                "snmp-agent community read cipher community123",
                "q",
                "save",
                "y"];
 
    for(host: hosts){
       sshConnection = host.ssh("admin", "admin");
       if(sshConnection != null){
           console = sshConnection.getConsole();
           console.expect(commandPrompt);
           for(command: commands){
               console.writeLine(command);
               console.expect(commandPrompt);
           }
           
           console.close();
           sshConnection.close();        
       }
    }
    ``` 
    Этот скрипт посещает все хосты из заданного списка, пытается соединиться с каждым по SSH, и в случае, если соединение удалось установить, выполняет серию команд. В данном случае мы поменяли SNMP community на 3-х устройствах под управлением ОС Huawei VRP и сохранили конфигурацию.
    
4. #### Зайти на устройство через веб-интерфейс
    ```javascript 1.8
    browser = firefox();
    if(browser.openPage("http://192.168.1.1")){
       browser.findElementById("username").sendKeys("admin");
       browser.findElementById("password").sendKeys("admin");
       browser.click(browser.findElementById("loginButton"));
    
       sleep(3000);
       println(browser.getPageTile());
    }
    browser.closeBrowser();
    ```
    Этот скрипт демонстрирует автоматизацию веб-интерфейсов. Запускается браузер FireFox и в нем открывается веб-интерфейс устройства с IP-адресом 192.168.1.1. Если HTML-страница открылась, то на ней ищутся текстовые поля для ввода имени пользователя и пароля, в них вводятся соответствующие данные. Далее скрипт нажимает на HTML-кнопку входа в устройство и ждет 3 секунды, позволяя браузеру подгрузить следующую страницу, после чего в консоль печатается заголовок этой страницы. После этого окно браузера закрывается.
    
### Ограничения
Формально Solarium является языком программирования общего назначения и теоретически его можно использовать для построения систем любой сложности. Но изначально он планировался как язык для написания коротких и "конкретных" скриптов, автоматизирующих простые повторяющиеся действия. В нем отсутствуют средства абстракции, нет сильной типизации, нет средств, позволяющих структурировать большие объемы кода. Это именно средство для автоматизации повседневной рутины сетевого администратора, выполненное в виде языка программирования для того, чтобы макисмально гибко адаптироваться под решение широкого круга задач. Solarium не является средством для написания больших и сложных программных систем, его ниша - это своего рода VBA для сетевого администратора.

### Запуск скриптов на Solarium.
Solarium является интерпретируемым языком, исходный код которого не преобразуется в тот или иной бинарный формат для последующего выполнения, а непосредственно читается и выполняется программой-интерпретатором. Для того, чтобы запустить скрипт на языке Solarium, необходимо сохранить его в текстовый файл в кодировке UTF-8. После этого нужно запустить интерпретатор и указать ему путь к файлу, содержащему скрипт:
```bash
java -jar solarium.jar /path/to/script.txt
```
Интерпретатор Solarium - это консольное приложение, написанное на Java и содержащееся вместе со всеми своими зависимостями в едином архиве solarium.jar. Для его запуска требуется JRE 1.8 или выше.

### Переменные и модель памяти.
Solarium является языком со слабой типизацией. Формальное объявление (declaration) переменных не требуется. Переменная автоматически определяется (definition) в момент ее первого использования. Переменные могут содержать скалярное значение или являться массивами. В обоих случаях переменная может содержать дополнительные именованные поля по примеру ООП-объектов. Значение каждого такого поля также может являться скаляром или массивом и содержать дополнительные именовааные поля. Следующий пример демонстрирует особенности работы с переменными в Solarium:
```javascript 1.8
/*Определяем переменные и присваиваем им начальные значения*/
a = 10;
b = "Some string";

/*b теперь становится массивом, строковое значение "Some string"
* забывается.*/
b = b.append(10);
b = b.append(20);

/*Напечатается: [10, 20]*/
println(b);

/*Добавляем в переменную a несколько полей. Теперь а является 
* аналогом объекта в ООП-языках. */
a.stringField = "Some string";
a.integerField = 100;

/*При этом скалярное значение 10, хранившееся в переменной a 
не забывается, следующий вызов напечатает: 10*/
println(a);
```
В версии языка 0.0.1 все переменные находятся на стеке и передаются только по значению. Используя термины C++ можно сказать, что здесь нет разделения на r-value и l-value, все является l-value.

### Операторы.
Поддерживаются стандартные арифметические операторы +,-,/,*,<,>,<=,>=,%. В текущей экспериментальной версии языка реализована только целочисленная арифметика. Таким образом:
```javascript 1.8
a = 25;

/*Напчатается: 2*/
println(a / 10);
```

Оператор "+" может применяться к строкам и означает конкатенацию:
```javascript 1.8
a = "Some ";
b = "string";

/*Напечатается: 'Some string'*/
print(a + b);
```

Поддерживаются логические операторы == (равно), != (не равно), !(отрицание), && (логическое И), || (логическое ИЛИ):
```javascript 1.8
/*Напечатает: true*/
println(!(10 != 11) || (10 == 10));
```

Поддерживаются стандартные правила ассоциативности операторов и скобки:
```javascript 1.8
/*Напечатается: 22*/
println(5 + 2*10 - 6/2);

a = true; b = false; c = true;

/*Напечатается: true*/
println(a || c && a || b);
```

### Строки
В предыдущем параграфе была рассмотрена конкатенация строк. Также при написании строковых литералов можно использовать escape sequences для добавления в строку специальных символов:
```javascript 1.8
a = "abc\ndef\tghi\"jkl\"";

/*Напечатает: 
* abc
* def   ghi"jkl"
* */
println(a);
```
Библиотека языка содержит некоторые функции, облегчающие работу со строками. Например, можно проверить содержит ли строка заданную подстроку:
```javascript 1.8
a = "abcd";

/*Напечатает: true*/
println(a.contains("bc"));
```
