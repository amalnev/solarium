# Solarium

Интерпретируемый язык программирования, нацеленный на автоматизацию рутинных задач сетевого администрирования. Также может применяться для организации автоматизированного тестирования веб-приложений и приложений с консольным интерфейсом.

### Область применения
Основная область применения данного языка - автоматизация задач сетевого администриования на больших сетях, построенных на оборудовании разных вендоров. Работа администратора таких сетей зачастую связана с рутинными операциями, которые нужно выполнить на большом количестве разных устройств, предоставляющих разные интерфейсы управления - консоли с разными языками конфигурирования, веб-интерфейсы, отличающиеся от устройства к устройству и от одной версии прошивки к другой и т.д. "Большие" корпоративные сетевые решения от ведущих вендоров, применяющиеся крупными операторами связи, как правило предоставляют унифицированные средства управления, но существует и сегмент операторов последних миль и сетей уровня доступа, применяющих более простые решения, не снабженные подобными мощными средствами управления "из коробки". Такие сети могут представлять собой набор из разнообразных элементов, относящихся как к "операторскому", так и к более низким классам надежности, произведенных различными вендорами и т.д., при этом сохраняется необходимость соблюдать некоторую степень единообразия в их конфигурации, применяющихся версиях прошивок, наименовании устройств и сервисов. Все это приводит к тому, что рано или поздно перед администратором такой сети ставятся задачи наподобие "поменять SNMP community на всех сетевых устройствах" или "определить все устройства определенного типа с определенной версией прошивки для последующего обновления". Solarium позволяет автоматизировать выполнение подобных задач. Solarium - это средство автоматизации пользовательских интерфейсов, выполненное в виде языка программирования. На этом языке можно писать скрипты, манипулирующие непосредственно интерфейсами сетевых устройств так, как это делал бы сетевой администратор "руками". С точки зрения устройства нет разницы, кто с ним взаимодействует - живой человек или Solarium-робот, поэтому никакой дополнительной поддержки со стороны управляемых устройств не требуется.

### Примеры
Перед тем как перейти к формальному описанию языка и его возможностей, приведем несколько быстрых и простых примеров Solarium-скриптов.

1. #### Определить устройства, отвечающие на пинг
    ```javascript 1.8
    for(ipAddress: ipRange("192.168.1.0/24")){
       if(ipAddress.isReachable())
           println(ipAddress);
    }
    ```
    Как видно из этого примера, язык обладает C-образным синтаксисом, поддерживает такие примитивы как переменные, функции и управляющие конструкции, например циклы "for" и ветвления. В данном конкретном случае встроенная функция ```ipRange()``` разворачивает стандартную нотацию IPv4-подсети в массив отдельных адресов, принадлежащих к этой подсети. Далее цикл ```for``` пробегает по всем элементам данного массива и с помощью встроенной функции ```isReachable()``` проверяет доступность соответствующего адреса с помощью ICMP echo, более известного как ping. В случае, если выражение ```ipAddress.isReachable()``` оценивается как ```true``` (то есть адрес пингуется), то данный адрес будет напечатан в консоль, из которой скрипт был запущен.

2. #### Опросить устройства по SNMP
    ```javascript 1.8
   for(ipAddress: ipRange("10.123.22-23.0-255")){
       if(ipAddress.isReachable()){
           hostname = getOID("1.3.6.1.2.1.1.5.0", ipAddress, "public", "1");
           if(hostname != null){
               println(ipAddress + " -> " + hostname);
           }
       }
   }
    ```
    Данный скрипт проверяет все IP-адреса из заданного диапазона и для тех адресов, которые оказываются доступны по пингу, пытается получить значение SNMP-объекта "1.3.6.1.2.1.1.5.0" (т.е. сетевое имя устройства) по протоколу SNMP 1-й версии, используя community "public". Это делается с помощью встроенной функции ```getOID()```, результат ее работы сохраняется в переменную ```hostname```. В случае, если вызов функции завершился успешно, в консоль выводится IP-адрес успешно опрошенного устройства и его сетевое имя.
    
3. #### Зайти на устройство и выполнить консольные команды
    Довольно часто встречающаяся в реальной работе задача - обновить конфигурацию на нескольких однотипных устройствах. Вот как это можно сделать с помощью Solarium:
    ```javascript 1.8
    hosts = ["192.168.1.1", "192.168.2.14", "10.10.1.34"];
    commandPrompt = "[>|\\]]";
    commands = ["system-view", 
                "snmp-agent community read cipher community123",
                "q",
                "save",
                "y"];
 
    for(host: hosts){
       sshConnection = host.ssh("admin", "admin");
       if(sshConnection != null){
           console = sshConnection.getConsole();
           console.expect(commandPrompt);
           for(command: commands){
               console.writeLine(command);
               console.expect(commandPrompt);
           }
           
           console.close();
           sshConnection.close();        
       }
    }
    ``` 
    Этот скрипт посещает все хосты из заданного списка, пытается соединиться с каждым по SSH, и в случае, если соединение удалось установить, выполняет серию команд. В данном случае мы поменяли SNMP community на 3-х устройствах под управлением ОС Huawei VRP и сохранили конфигурацию.
    
4. #### Зайти на устройство через веб-интерфейс
    ```javascript 1.8
    browser = firefox();
    if(browser.openPage("http://192.168.1.1")){
       browser.findElementById("username").sendKeys("admin");
       browser.findElementById("password").sendKeys("admin");
       browser.click(browser.findElementById("loginButton"));
    
       sleep(3000);
       println(browser.getPageTile());
    }
    browser.closeBrowser();
    ```
    Этот скрипт демонстрирует автоматизацию веб-интерфейсов. Запускается браузер FireFox и в нем открывается веб-интерфейс устройства с IP-адресом 192.168.1.1. Если HTML-страница открылась, то на ней ищутся текстовые поля для ввода имени пользователя и пароля, в них вводятся соответствующие данные. Далее скрипт нажимает на HTML-кнопку входа в устройство и ждет 3 секунды, позволяя браузеру подгрузить следующую страницу, после чего в консоль печатается заголовок этой страницы. После этого окно браузера закрывается.
    
### Ограничения
Формально Solarium является языком программирования общего назначения и теоретически его можно использовать для построения систем любой сложности. Но изначально он планировался как язык для написания коротких и "конкретных" скриптов, автоматизирующих простые повторяющиеся действия. В нем отсутствуют средства абстракции, нет сильной типизации, нет средств, позволяющих структурировать большие объемы кода. Это именно средство для автоматизации повседневной рутины сетевого администратора, выполненное в виде языка программирования для того, чтобы макисмально гибко адаптироваться под решение широкого круга задач. Solarium не является средством для написания больших и сложных программных систем, его ниша - это своего рода VBA для сетевого администратора.

### Запуск скриптов на Solarium.
Solarium является интерпретируемым языком, исходный код которого не преобразуется в тот или иной бинарный формат для последующего выполнения, а непосредственно читается и выполняется программой-интерпретатором. Для того, чтобы запустить скрипт на языке Solarium, необходимо сохранить его в текстовый файл в кодировке UTF-8. После этого нужно запустить интерпретатор и указать ему путь к файлу, содержащему скрипт:
```bash
java -jar solarium.jar /path/to/script.txt
```
Интерпретатор Solarium - это консольное приложение, написанное на Java и содержащееся вместе со всеми своими зависимостями в едином архиве solarium.jar. Для его запуска требуется JRE 1.8 или выше.

### Переменные и модель памяти.
Solarium является языком со слабой типизацией. Формальное объявление (declaration) переменных не требуется. Переменная автоматически определяется (definition) в момент ее первого использования. Переменные могут содержать скалярное значение или являться массивами. В обоих случаях переменная может содержать дополнительные именованные поля по примеру ООП-объектов. Значение каждого такого поля также может являться скаляром или массивом и содержать дополнительные именовааные поля. Следующий пример демонстрирует особенности работы с переменными в Solarium:
```javascript 1.8
/*Определяем переменные и присваиваем им начальные значения*/
a = 10;
b = "Some string";

/*b теперь становится массивом, строковое значение "Some string"
* забывается.*/
b = b.append(10);
b = b.append(20);

/*Напечатается: [10, 20]*/
println(b);

/*Добавляем в переменную a несколько полей. Теперь а является 
* аналогом объекта в ООП-языках. */
a.stringField = "Some string";
a.integerField = 100;

/*При этом скалярное значение 10, хранившееся в переменной a 
не забывается, следующий вызов напечатает: 10*/
println(a);

/*Помимо строковых и целочисленных литералов поддерживается также
* специальное значение null*/
c = null;
```
В версии языка 0.0.1 все переменные находятся на стеке и передаются только по значению. Используя термины C++ можно сказать, что здесь нет разделения на r-value и l-value, все является l-value.

### Операторы.
Поддерживаются стандартные арифметические операторы +,-,/,*,<,>,<=,>=,%. В текущей экспериментальной версии языка реализована только целочисленная арифметика. Таким образом:
```javascript 1.8
a = 25;

/*Напчатается: 2*/
println(a / 10);
```

Оператор "+" может применяться к строкам и означает конкатенацию:
```javascript 1.8
a = "Some ";
b = "string";

/*Напечатается: 'Some string'*/
print(a + b);
```

Поддерживаются логические операторы == (равно), != (не равно), !(отрицание), && (логическое И), || (логическое ИЛИ):
```javascript 1.8
/*Напечатает: true*/
println(!(10 != 11) || (10 == 10));
```

Поддерживаются стандартные правила ассоциативности операторов и скобки:
```javascript 1.8
/*Напечатается: 22*/
println(5 + 2*10 - 6/2);

a = true; b = false; c = true;

/*Напечатается: true*/
println(a || c && a || b);
```

### Строки и регулярные выражения
В предыдущем параграфе была рассмотрена конкатенация строк. Также при написании строковых литералов можно использовать escape sequences для добавления в строку специальных символов:
```javascript 1.8
a = "abc\ndef\tghi\"jkl\"";

/*Напечатает: 
* abc
* def   ghi"jkl"
* */
println(a);
```
Библиотека языка содержит некоторые функции, облегчающие работу со строками. Например, можно проверить содержит ли строка заданную подстроку:
```javascript 1.8
a = "abcd";

/*Напечатает: true*/
println(a.contains("bc"));
```
Можно проверить, является ли заданная подстрока префиксом некоторой строки:
```javascript 1.8
a = "abcd";

/*Напечатает: true*/
println(a.contains("ab"));
```
Конвертирование символы в заглавные:
```javascript 1.8
a = "abcd";

/*Напечатает: ABCD*/
println(a.toUpperCase());
```
Проверка, удовлетворяет ли некоторая строка заданному регулярному выпражению:
```javascript 1.8
a = "abcd";

/*Напечатает: true*/
println(a.matches("[a-z]+"));
```
Наконец, приведем пример парсинга текста с помощью регулярного выражения. Функция grep() возвращает массив, в котором каждый элемент соответствует одному найденному совпадению в исходном тексте. При этом каждый элемент возвращаемого массива в свою очередь является массивом, состоящим из строк, соответствующих подгруппам регулярного выражения - 0-й элемент дает всю найденную строку, 1-й и далее - дают подстроки, соответсвующие подгруппам, если таковые присутствовали в регулярном выражении. Например:
```javascript 1.8
text = "abcd 11-45 fdgr 2-00";
pattern = "([0-9]+)-([0-9]+)";
for(match: pattern.grep(text)) {
    for(submatch: match){
        println(submatch);
    }
}

/*Будет напечатано:
  11-45 (первое совпадение целиком)
  11 (первая подгруппа в первом совпадении)
  45 (вторая подгруппа в первом совпадении)
  2-00 (второе совпадение целиком)
  2 (первая подгруппа во втором совпадении)
  00 (вторая подгруппа во втором совпадении)
 */
``` 
### Управляющие конструкции
Язык поддерживает полный набор управляющих конструкций. Ветвления:
```javascript 1.8
if(expression_returning_boolean) {
    //...
}
else if(expression_returning_boolean) {
    //...
}
else {
    //...
}
```
Циклы for со счетчиком:
```javascript 1.8
for(i = 0; i < 10; i = i + 1) {
    /*К сожалению, в экспериментальной версии нет поддержки операторов ++ и --.*/
}
```
Циклы for по массиву элементов:
```javascript 1.8
arr = [10, 20, 30];
for(element: arr) {
    println(element);
}

/*Напечатает:
 10
 20
 30
*/
```
Циклы do-while:
```javascript 1.8
do {
    /*Infinite loop*/
} while(true);
```
Циклы while:
```javascript 1.8
while (true) {
    /*Infinite loop*/
} 
```
Внутри циклов можно использовать операторы break и continue:
```javascript 1.8
arr = [10, 20, 30, 40, 50, 60];
for(element: arr) {
    if(element < 30) continue;
    if(element > 40) break;
    println(element);
}

/*Напечатает:
 30
 40
*/
```

### Функции
Язык позволяет выделять часть кода в функцию и вызывать ее из другой функции:
```javascript 1.8
function f(a){
    return a + 10;
}

/*Напечатается: 20*/
println(f(10));
```
В приведенном выше примере строка кода ```println(f());``` не содержится внутри какой-либо функции. Интерпретатор начнет выполнение данного скрипта именно с первой строки, не находящейся внутри функции. Увидев, что для выполнения этой строки нужно вызвать функцию f(), интерпретатор найдет ее определение и вызовет с заданными праметрами. Парасетры передаются в функцию всегда по значению:
```javascript 1.8
function f(a, b) {
    a = a + 10;
    b = b + 20;
}

x = 10; y = 20;
f(x, y);

/*Напечатается: 10*/
println(x);

/*Напечатается: 20*/
println(y);
```
При вызове функции интепретатор завершает выполнение ее кода достигнув последней инструкции в теле функции или встретив оператор return. Кроме того, оператор return - единственный способ вернуть из функции какое-либо значение. Если функция в явном виде не возвращает никакого значения, то по умолчанию считается, что она вернула null:
```javascript 1.8
function f(){
    //do something
    return;
}

/*Напечатает true*/
println(f() == null);
```
Язык подерживает специальный ООП-образный синтаксис для вызова функций - "через точку":
```javascript 1.8
function plus(x, y) {
    return x + y;
}

a = 10; b = 20;

/*Напечатает: 30*/
println(a.plus(b));

/*Напечатает: 30*/
print(plus(a,b));

```
То есть для функции ```f(x, y)``` вызов ```x.f(y)``` эквивалентен вызову ```f(x, y)```.

### Исходные файлы и препроцессор
Как уже говорилось выше, для запуска скрипта на языке Solarium, его необходимо сохранить в текстовый файл в кодировке UTF-8 и передать на выполнение интерпретатору. Интерпретатор открывает переданный ему файл, и начинает выполнять построчно, начиная с первой строки кода, не содержащейся в той или иной функции. Код, содержащийся в функциях, выполняется при вызове этих функций. Но еще до того, как интерпретатор получит доступ к исходному коду, он обрабатывается перепроцессором. Задача перпроцессора заключается в подготовке исходного кода к интерпретации, при этом автор скрипта может влиять на этот процесс при помощи директив препроцессора, по аналогии с языками С/С++. В экспериментальной версии Solarium поддерживается только одна препроцессорная директива - #include. Она позволяет разбить большой скрипт на несколько исходных файлов, а перед интерпретацией объединить их. Например, на диске есть директория scripts, содержащая скрипты main.txt и functions.txt, а также вложенная директория library, содержащая скрипт library.txt:
 ```bash
$ ls -lRa
.:
total 12
drwxr-xr-x 3 amalnev amalnev 4096 Nov 19 14:45 .
drwxr-xr-x 3 amalnev amalnev 4096 Nov 19 14:45 ..
-rw-r--r-- 1 amalnev amalnev    0 Nov 19 14:45 functions.txt
drwxr-xr-x 2 amalnev amalnev 4096 Nov 19 14:45 library
-rw-r--r-- 1 amalnev amalnev    0 Nov 19 14:45 main.txt

./library:
total 8
drwxr-xr-x 2 amalnev amalnev 4096 Nov 19 14:45 .
drwxr-xr-x 3 amalnev amalnev 4096 Nov 19 14:45 ..
-rw-r--r-- 1 amalnev amalnev    0 Nov 19 14:45 library.txt
```

Предположим, что скрипт library.txt содержит некоторые "библиотечные" функции:
```javascript 1.8
/*Содержимое library.txt*/
function sum (a, b) {
    return a + b;
}

function div (a, b) {
    return a / b;
}
```

Скрипт functions.txt использует "библиотечные" функции:
```javascript 1.8
/*Содержимое functions.txt*/

#include("library/library.txt");

function avg(arr) {
    arrayTotal = 0;
    for(element: arr) {
        arrayTotal = arrayTotal.sum(element);
    }
    
    return arrayTotal.div(arr.size());
}
```

Скрипт main.txt - это точка входа, с которой интерпретатор будет начинать работу, когда мы запустим его при помощи команды ```java -jar solarium.jar main.txt```:
```javascript 1.8
#include("functions.txt");

a = [10, 20, 30];

/*Напечатает: 20*/
println(a.avg());
```

Что происходит в приведенном выше примере? Препроцессор читает исходный код, начиная с файла main.txt, поскольку именно его мы указали как точку входа при запуске Solarium-а. Увидев директиву ```#include("functions.txt");``` препроцессор открывает указанный файл, рекурсивно обрабатывает его и результат подставляет вместо текста директивы #include. Таким образом, интерпретатору на выполнение попадет исходный код, "сшитый" из содержимого нескольких файлов. Необходимо заметить, что пути к файлам в директиве #include всегда интерпретируются относительно той директории, в которой находится файл, содержащий данную директиву. 

### Библиотека
